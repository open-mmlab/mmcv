
./csrc/pytorch/info.cpp:15:#include <cuda_runtime_api.h>
./csrc/pytorch/info.cpp:16:int get_cudart_version() { return CUDART_VERSION; }
./csrc/pytorch/info.cpp:20:std::string get_compiling_cuda_version() {
./csrc/pytorch/info.cpp:25:  // https://github.com/pytorch/pytorch/blob/master/aten/src/ATen/cuda/detail/CUDAHooks.cpp#L231
./csrc/pytorch/info.cpp:32:  printCudaStyleVersion(get_cudart_version());
./csrc/pytorch/bbox_overlaps.cpp:37:  bool is_mock_cuda = bboxes1.device().type() == dipu::DIPU_DEVICE_TYPE;
./csrc/pytorch/bbox_overlaps.cpp:38:  if (is_mock_cuda &&
./csrc/pytorch/pybind.cpp:7:std::string get_compiling_cuda_version();
./csrc/pytorch/pybind.cpp:502:  m.def("get_compiling_cuda_version", &get_compiling_cuda_version,
./csrc/pytorch/pybind.cpp:503:        "get_compiling_cuda_version");
./csrc/pytorch/rotated_feature_align.cpp:3:// https://github.com/SJTU-Thinklab-Det/r3det-on-mmdetection/blob/master/mmdet/ops/fr/src/feature_refine_cuda.cpp
./csrc/pytorch/roi_align.cpp:61:  bool is_mock_cuda = input.device().type() == dipu::DIPU_DEVICE_TYPE;
./csrc/pytorch/roi_align.cpp:62:  if (is_mock_cuda && reinterpret_cast<void *>(diopiRoiAlignMmcv) != nullptr) {
./csrc/pytorch/roi_align.cpp:108:  bool is_mock_cuda = grad_output.device().type() == dipu::DIPU_DEVICE_TYPE;
./csrc/pytorch/roi_align.cpp:109:  if (is_mock_cuda &&


./info.py:10:    def get_compiling_cuda_version():
./info.py:11:        return parrots.version.cuda
./info.py:15:        '_ext', ['get_compiler_version', 'get_compiling_cuda_version'])
./info.py:20:    def get_compiling_cuda_version():
./info.py:21:        return ext_module.get_compiling_cuda_version()
